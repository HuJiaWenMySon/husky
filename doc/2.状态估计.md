# 状态估计

状态估计是算法的核心模块之一。对于移动机器人，最常用的估计方法就是融合里程计和IMU。激光雷达和视觉在其他移动机器人里常常作为辅助，但是对于足式机器人而言，平衡控制的频率太高，不太可能使用运算量过大的算法。

## IMU

IMU是移动机器人上最重要的传感器没有之一，这是由于它测量的量过于重要：

- 3维线性加速度：通过一个加速度计测量；
- 3维角速度：通过一个陀螺仪测量；

关于IMU的测量原理是一个专门的学问，不建议深究，这里只讨论其数据的处理。假设加速度计的读数为$a_{out}$，这是在IMU自身的随体坐标系下的值，需要通过旋转矩阵转到世界坐标系下面，同时考虑重力加速度
$$
a_s = R_{sb}a_{out}+g
$$
IMU的角速度也是在随体坐标系下的值，严格来说需要通过旋转矩阵转移到世界系。但是在移动过程中一般保持Roll-Pitch不变，可以近似用IMU的第三轴角速度代替Yaw Rate。

## 机身速度

机身速度的计算是比较有技巧性的地方。首先，足端相对于机身的速度可以通过雅可比计算，那么对于支撑腿，其在世界坐标系下的速度为0，就可以反推机身的速度了。机身坐标系下，足端因机身运动的牵连速度为：
$$
v_{be}=v_b+\omega_b\times p_{bfB}
$$
它包含机身带来的线速度，以及机身角速度在$p_{bfB}$向量下产生的速度。足端因电机转动带来的速度$v_{bj}=J\dot\theta$。因此足端在世界坐标系下的速度就是：
$$
v_{sf}=v_s+R_{sb}(\omega_b\times p_{bfB}+J\dot \theta)=0
$$
利用这个式子就可以求解机身速度$v_s$，这个值将作为卡尔曼滤波器的观测值。

## 卡尔曼滤波

利用雅可比反推的机身速度一般精度比较有限，IMU测得的线性加速度一般精度比较高，此时就可以考虑使用卡尔曼滤波进行数据融合。对于机身速度而言，状态空间方程非常简单：
$$
v_{k} = v_{k-1} + a\Delta t\\
$$
$v_k$的观测值可以从上一节的方程中给出。因此可以进行卡尔曼滤波了。卡尔曼滤波的流程如下：

1. 初始化**先验协方差矩阵P**，**过程误差Q**和**测量误差R**；
2. 初始化状态变量，即机身线速度为0，这个值是随便给的，但一般估计器启动时机器人确实还没有开始动；
3. 预测：在第k时刻，计算先验估计$\hat x_k^-$和先验协方差$\hat P_k^-$；
4. 更新：计算Kalman Gain $K_k$，然后利用测量值，更新后验估计$\hat x_1^+$和后验协方差矩阵$P_k^+$；

这里的$A=I$，输出$y_k=v_k$，因此$C=I$，所以Kalman滤波器写起来很容易：

```cpp
void VelocityEstimator::KalmanFilterPredict()
{
    //根据状态转移方程进行先验估计
    X_ = X_ + BU_;  //Vn+1 = Vn + aT;
    //更新先验状态估计的协方差矩阵，A是单位阵
    P_ = P_ + Q_;
}


/**
 * @brief 卡尔曼滤波器的更新步骤
 * 
 */
void VelocityEstimator::KalmanFilterUpdate()
{
    //计算kalman增益
    K_ = P_*(P_+R_).inverse();

    //i计算后验状态估计
    X_ = X_ + K_*(Z_-X_);

    //更新后验状态估计的协方差矩阵
    P_ = (Mat3::Identity() - K_)*P_;
}
```

这样就得到了质心线速度这一重要数据，而角速度可以直接通过IMU读出来。

## 质心位置估计

对于位置，可以放在一个状态空间方程进行卡尔曼滤波，无非是使得状态空间方程复杂一些。这里考虑到没有对位置进行比较精确的反馈控制，采用了平面二维里程计方法。首先从IMU获取当前的yaw角度，然后将质心的x，y速度投影在x，y轴上，对二维里程计进行积分即可。

需要关注的是在z方向不能使用这种方法，因为其具有比较大的噪声，而在机身高度上需要进行精确的控制，因为机身高度直接影响步态的稳定，我们不能让机器人上下不停起伏。采用的方法是通过支撑腿的正向运动学估计高度。

```cpp
float PoseEstimator::EstimateHeight()
{
    Mat3 Rwb = QuatToRotMat(robot_->base_orientation_);//获取基坐标系到世界坐标系的旋转矩阵
    Mat34 foot_positions_in_base_frame = robot_->foot_to_base_positions_in_base_frame_;
    Vec4 useful_heights_;
    Eigen::Matrix<int, 1, 4> contacts;

    for(int i = 0; i < 4; i++)
    {
        if(robot_->foot_contact_[i]) //只有处于支撑状态，才可以使用运动学计算高度
        {
            contacts[i] = true;
        }
        else
        {
            contacts[i] = false;
        }
    }
    if (contacts.sum() == 0) 
    {
        return robot_->base_position_[2];
    } 
    else 
    {
        Mat34 foot_positions_in_world_frame = Rwb*foot_positions_in_base_frame;
        useful_heights_ = -foot_positions_in_world_frame.block<1, 4>(2, 0).cwiseProduct(contacts.cast<float>());
        // printf("%f,%d\r\n",useful_heights_.sum() / contacts.sum(),contacts.sum());
        return useful_heights_.sum() / contacts.sum();
    }
}
```

## 参数调试

卡尔曼滤波器参数主要包含初始状态，初始最优估计协方差、测量噪声协方差和过程噪声协方差。其中，测量噪声协方差可以通过测量得到，初始状态一般是未知的，因此最优估计协方差会给一个比较大的值，待后续迭代收敛。而过程噪声协方差是需要调试的。如果Q太小。表示对状态空间模型比较信任，此时如果模型精度比较差，会导致估计的结果出错，可能导致模型无法收敛。而如果Q太大，相对而言就表明信任测量值。如果测量值噪声比较大，就会导致估计器计算得到的最优状态包含比较大的误差，从而使得状态变量高频振动。因此，调参的方法一般是先给一个比较大的过程噪声Q，如果产生了高频振动，则逐渐减小Q。

对于本例则比较特殊，因为过程误差的来源主要是加速度计的系统误差，也是可以测量出来的。同时，初始状态我们是已知的静止状态，初始协方差也就不需要设置得很大了，因此本例的参数调试比较简单。

## 算法输出

经过状态估计模块，实际上知道机器人在世界坐标系下每个点的位姿和速度。





